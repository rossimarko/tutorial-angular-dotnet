# Module 4: SQL Server with Dapper Data Access

## üéØ Objectives

By the end of this module, you will:
- ‚úÖ Create and initialize a SQL Server database with Docker
- ‚úÖ Design database schema for the CRUD application
- ‚úÖ Implement Dapper ORM with repositories
- ‚úÖ Create database migrations
- ‚úÖ Write efficient queries with Dapper
- ‚úÖ Understand async database operations

## üê≥ SQL Server Setup with Docker

From Module 1, you have Docker Compose configured. The SQL Server container should be ready to use.

### Step 1: Start SQL Server Container

```powershell
cd d:\Formazione\tutorial-angular-dotnet\docker

# Start only the SQL Server container
docker-compose up -d sqlserver

# Verify it's running
docker-compose ps

# Should show: sqlserver   ... Up (healthy)
```

### Step 2: Connect to SQL Server

You can connect using:

```powershell
# Using Docker exec (inside container)
docker exec -it projecttracker_sqlserver sqlcmd -S localhost -U sa -P "YourPassword123!@#"

# Or use SQL Server Management Studio
# Server: localhost,1433
# User: sa
# Password: YourPassword123!@#
```

## üìä Database Design

### Entity Relationship Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Users       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Id (PK)         ‚îÇ
‚îÇ Email (UQ)      ‚îÇ
‚îÇ PasswordHash    ‚îÇ
‚îÇ FirstName       ‚îÇ
‚îÇ LastName        ‚îÇ
‚îÇ CreatedAt       ‚îÇ
‚îÇ UpdatedAt       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ1
         ‚îÇ 1:N
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Projects     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Id (PK)         ‚îÇ
‚îÇ UserId (FK)     ‚îÇ
‚îÇ Title           ‚îÇ
‚îÇ Description     ‚îÇ
‚îÇ Status          ‚îÇ
‚îÇ Priority        ‚îÇ
‚îÇ CreatedAt       ‚îÇ
‚îÇ UpdatedAt       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ RefreshTokens   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Id (PK)         ‚îÇ
‚îÇ UserId (FK)     ‚îÇ
‚îÇ Token           ‚îÇ
‚îÇ ExpiresAt       ‚îÇ
‚îÇ CreatedAt       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üî® Create Database Migrations

Create folder: `backend/ProjectTracker.API/Data/Migrations`

### Step 1: Initial Schema Migration

Create file: `backend/ProjectTracker.API/Data/Migrations/001_InitialCreate.sql`

```sql
-- Create Users table
CREATE TABLE [Users] (
    [Id] INT PRIMARY KEY IDENTITY(1,1),
    [Email] NVARCHAR(255) NOT NULL UNIQUE,
    [PasswordHash] NVARCHAR(MAX) NOT NULL,
    [FirstName] NVARCHAR(100),
    [LastName] NVARCHAR(100),
    [IsActive] BIT DEFAULT 1,
    [CreatedAt] DATETIME2 DEFAULT GETUTCDATE(),
    [UpdatedAt] DATETIME2 DEFAULT GETUTCDATE()
);

-- Create index on Email for faster lookups
CREATE INDEX [IX_Users_Email] ON [Users]([Email]);

-- Create Projects table
CREATE TABLE [Projects] (
    [Id] INT PRIMARY KEY IDENTITY(1,1),
    [UserId] INT NOT NULL,
    [Title] NVARCHAR(255) NOT NULL,
    [Description] NVARCHAR(MAX),
    [Status] NVARCHAR(50) DEFAULT 'Active',
    [Priority] INT DEFAULT 1,
    [StartDate] DATETIME2,
    [DueDate] DATETIME2,
    [CreatedAt] DATETIME2 DEFAULT GETUTCDATE(),
    [UpdatedAt] DATETIME2 DEFAULT GETUTCDATE(),
    FOREIGN KEY ([UserId]) REFERENCES [Users]([Id]) ON DELETE CASCADE
);

-- Create index on UserId for faster lookups
CREATE INDEX [IX_Projects_UserId] ON [Projects]([UserId]);

-- Create RefreshTokens table
CREATE TABLE [RefreshTokens] (
    [Id] INT PRIMARY KEY IDENTITY(1,1),
    [UserId] INT NOT NULL,
    [Token] NVARCHAR(MAX) NOT NULL,
    [ExpiresAt] DATETIME2 NOT NULL,
    [RevokedAt] DATETIME2,
    [CreatedAt] DATETIME2 DEFAULT GETUTCDATE(),
    FOREIGN KEY ([UserId]) REFERENCES [Users]([Id]) ON DELETE CASCADE
);

-- Create index on UserId and ExpiresAt
CREATE INDEX [IX_RefreshTokens_UserId_ExpiresAt] ON [RefreshTokens]([UserId], [ExpiresAt]);

-- Create seed data script
INSERT INTO [Users] ([Email], [PasswordHash], [FirstName], [LastName])
VALUES ('demo@example.com', '$2a$11$PLACEHOLDER_BCRYPT_HASH_HERE', 'Demo', 'User');

-- The actual bcrypt hash will be generated by the C# code during authentication module
```

### Step 2: Migration Helper

Create file: `backend/ProjectTracker.API/Data/MigrationRunner.cs`

```csharp
using System.Reflection;
using Dapper;
using System.Data;
using Microsoft.Data.SqlClient;

namespace ProjectTracker.API.Data;

/// <summary>
/// Runs SQL migrations from migration scripts
/// </summary>
public class MigrationRunner
{
    private readonly string _connectionString;
    private readonly ILogger<MigrationRunner> _logger;

    public MigrationRunner(string connectionString, ILogger<MigrationRunner> logger)
    {
        _connectionString = connectionString;
        _logger = logger;
    }

    /// <summary>
    /// Execute all migrations in order
    /// </summary>
    public async Task RunMigrationsAsync()
    {
        try
        {
            // Create migrations table if it doesn't exist
            using (var connection = new SqlConnection(_connectionString))
            {
                await connection.OpenAsync();

                const string createMigrationsTableSql = @"
                    IF NOT EXISTS (SELECT 1 FROM sys.tables WHERE name = 'Migrations')
                    BEGIN
                        CREATE TABLE [Migrations] (
                            [Id] INT PRIMARY KEY IDENTITY(1,1),
                            [Version] NVARCHAR(100) NOT NULL UNIQUE,
                            [AppliedAt] DATETIME2 DEFAULT GETUTCDATE()
                        );
                    END";

                await connection.ExecuteAsync(createMigrationsTableSql);
            }

            // Get list of migration files
            var migrationPath = Path.Combine(
                AppDomain.CurrentDomain.BaseDirectory,
                "Data", "Migrations");

            if (!Directory.Exists(migrationPath))
            {
                _logger.LogWarning("Migrations directory not found at {Path}", migrationPath);
                return;
            }

            var migrationFiles = Directory.GetFiles(migrationPath, "*.sql")
                .OrderBy(f => f)
                .ToList();

            foreach (var file in migrationFiles)
            {
                var fileName = Path.GetFileName(file);
                await RunMigrationAsync(fileName, file);
            }

            _logger.LogInformation("All migrations completed successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error running migrations: {Message}", ex.Message);
            throw;
        }
    }

    /// <summary>
    /// Run a single migration file
    /// </summary>
    private async Task RunMigrationAsync(string version, string filePath)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            await connection.OpenAsync();

            // Check if migration already applied
            var alreadyApplied = await connection.QuerySingleOrDefaultAsync<int>(
                "SELECT COUNT(*) FROM Migrations WHERE Version = @Version",
                new { Version = version });

            if (alreadyApplied > 0)
            {
                _logger.LogInformation("Migration {Version} already applied, skipping", version);
                return;
            }

            try
            {
                // Read migration file
                var sql = await File.ReadAllTextAsync(filePath);

                // Execute migration
                await connection.ExecuteAsync(sql);

                // Record migration as applied
                await connection.ExecuteAsync(
                    "INSERT INTO Migrations (Version) VALUES (@Version)",
                    new { Version = version });

                _logger.LogInformation("Migration {Version} applied successfully", version);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error applying migration {Version}: {Message}", version, ex.Message);
                throw;
            }
        }
    }
}
```

## üèó Database Models

Create folder: `backend/ProjectTracker.API/Models/Entities`

### Step 1: User Entity

Create file: `backend/ProjectTracker.API/Models/Entities/User.cs`

```csharp
namespace ProjectTracker.API.Models.Entities;

/// <summary>
/// User entity representing a registered user
/// </summary>
public class User
{
    public int Id { get; set; }
    public required string Email { get; set; }
    public required string PasswordHash { get; set; }
    public string? FirstName { get; set; }
    public string? LastName { get; set; }
    public bool IsActive { get; set; } = true;
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }

    public string FullName => $"{FirstName} {LastName}".Trim();
}
```

### Step 2: Project Entity

Create file: `backend/ProjectTracker.API/Models/Entities/Project.cs`

```csharp
namespace ProjectTracker.API.Models.Entities;

/// <summary>
/// Project entity
/// </summary>
public class Project
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public required string Title { get; set; }
    public string? Description { get; set; }
    public string Status { get; set; } = "Active";
    public int Priority { get; set; } = 1;
    public DateTime? StartDate { get; set; }
    public DateTime? DueDate { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }

    // Navigation property (not mapped to DB, populated by repository)
    public User? User { get; set; }
}
```

### Step 3: RefreshToken Entity

Create file: `backend/ProjectTracker.API/Models/Entities/RefreshToken.cs`

```csharp
namespace ProjectTracker.API.Models.Entities;

/// <summary>
/// Refresh token for JWT authentication
/// </summary>
public class RefreshToken
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public required string Token { get; set; }
    public DateTime ExpiresAt { get; set; }
    public DateTime? RevokedAt { get; set; }
    public DateTime CreatedAt { get; set; }

    public bool IsExpired => DateTime.UtcNow >= ExpiresAt;
    public bool IsRevoked => RevokedAt is not null;
    public bool IsValid => !IsExpired && !IsRevoked;
}
```

## üíæ Repository Pattern with Dapper

Create folder: `backend/ProjectTracker.API/Data/Repositories`

### Step 1: DbConnection Helper

Create file: `backend/ProjectTracker.API/Data/DbConnection.cs`

```csharp
using Microsoft.Data.SqlClient;
using System.Data;

namespace ProjectTracker.API.Data;

/// <summary>
/// Helper for creating database connections
/// </summary>
public class DbConnection
{
    private readonly string _connectionString;

    public DbConnection(IConfiguration configuration)
    {
        _connectionString = configuration.GetConnectionString("DefaultConnection")
            ?? throw new InvalidOperationException("Connection string not found");
    }

    /// <summary>
    /// Create and open a new database connection
    /// </summary>
    public IDbConnection CreateConnection() => new SqlConnection(_connectionString);

    /// <summary>
    /// Create and open a new database connection asynchronously
    /// </summary>
    public async Task<IDbConnection> CreateConnectionAsync()
    {
        var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync();
        return connection;
    }
}
```

### Step 2: User Repository Interface

Create file: `backend/ProjectTracker.API/Data/Repositories/IUserRepository.cs`

```csharp
using ProjectTracker.API.Models.Entities;

namespace ProjectTracker.API.Data.Repositories;

/// <summary>
/// Repository interface for User operations
/// </summary>
public interface IUserRepository
{
    Task<User?> GetByIdAsync(int id);
    Task<User?> GetByEmailAsync(string email);
    Task<IEnumerable<User>> GetAllAsync();
    Task<int> CreateAsync(User user);
    Task<bool> UpdateAsync(User user);
    Task<bool> DeleteAsync(int id);
    Task<bool> EmailExistsAsync(string email);
}
```

### Step 3: User Repository Implementation

Create file: `backend/ProjectTracker.API/Data/Repositories/UserRepository.cs`

```csharp
using Dapper;
using ProjectTracker.API.Models.Entities;
using System.Data;

namespace ProjectTracker.API.Data.Repositories;

/// <summary>
/// Dapper-based implementation of IUserRepository
/// </summary>
public class UserRepository : IUserRepository
{
    private readonly DbConnection _dbConnection;
    private readonly ILogger<UserRepository> _logger;

    public UserRepository(DbConnection dbConnection, ILogger<UserRepository> logger)
    {
        _dbConnection = dbConnection;
        _logger = logger;
    }

    public async Task<User?> GetByIdAsync(int id)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                SELECT [Id], [Email], [PasswordHash], [FirstName], [LastName], 
                       [IsActive], [CreatedAt], [UpdatedAt]
                FROM [Users]
                WHERE [Id] = @Id";

            var user = await connection.QueryFirstOrDefaultAsync<User>(
                sql,
                new { Id = id });

            return user;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving user by id {UserId}", id);
            throw;
        }
    }

    public async Task<User?> GetByEmailAsync(string email)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                SELECT [Id], [Email], [PasswordHash], [FirstName], [LastName],
                       [IsActive], [CreatedAt], [UpdatedAt]
                FROM [Users]
                WHERE [Email] = @Email";

            var user = await connection.QueryFirstOrDefaultAsync<User>(
                sql,
                new { Email = email });

            return user;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving user by email {Email}", email);
            throw;
        }
    }

    public async Task<IEnumerable<User>> GetAllAsync()
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                SELECT [Id], [Email], [PasswordHash], [FirstName], [LastName],
                       [IsActive], [CreatedAt], [UpdatedAt]
                FROM [Users]
                ORDER BY [CreatedAt] DESC";

            var users = await connection.QueryAsync<User>(sql);
            return users;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving all users");
            throw;
        }
    }

    public async Task<int> CreateAsync(User user)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                INSERT INTO [Users] ([Email], [PasswordHash], [FirstName], [LastName], [IsActive])
                VALUES (@Email, @PasswordHash, @FirstName, @LastName, @IsActive);
                SELECT CAST(SCOPE_IDENTITY() as int)";

            var id = await connection.QuerySingleAsync<int>(
                sql,
                new
                {
                    user.Email,
                    user.PasswordHash,
                    user.FirstName,
                    user.LastName,
                    user.IsActive
                });

            _logger.LogInformation("User created with id {UserId}", id);
            return id;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating user with email {Email}", user.Email);
            throw;
        }
    }

    public async Task<bool> UpdateAsync(User user)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                UPDATE [Users]
                SET [Email] = @Email,
                    [FirstName] = @FirstName,
                    [LastName] = @LastName,
                    [IsActive] = @IsActive,
                    [UpdatedAt] = GETUTCDATE()
                WHERE [Id] = @Id";

            var rowsAffected = await connection.ExecuteAsync(
                sql,
                new
                {
                    user.Id,
                    user.Email,
                    user.FirstName,
                    user.LastName,
                    user.IsActive
                });

            _logger.LogInformation("User {UserId} updated", user.Id);
            return rowsAffected > 0;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating user {UserId}", user.Id);
            throw;
        }
    }

    public async Task<bool> DeleteAsync(int id)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = "DELETE FROM [Users] WHERE [Id] = @Id";

            var rowsAffected = await connection.ExecuteAsync(sql, new { Id = id });

            _logger.LogInformation("User {UserId} deleted", id);
            return rowsAffected > 0;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting user {UserId}", id);
            throw;
        }
    }

    public async Task<bool> EmailExistsAsync(string email)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = "SELECT COUNT(*) FROM [Users] WHERE [Email] = @Email";

            var count = await connection.QuerySingleAsync<int>(
                sql,
                new { Email = email });

            return count > 0;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking if email exists {Email}", email);
            throw;
        }
    }
}
```

### Step 4: Project Repository

Similarly, create `IProjectRepository.cs` and `ProjectRepository.cs`:

Create file: `backend/ProjectTracker.API/Data/Repositories/IProjectRepository.cs`

```csharp
using ProjectTracker.API.Models.Common;
using ProjectTracker.API.Models.Entities;

namespace ProjectTracker.API.Data.Repositories;

/// <summary>
/// Repository interface for Project operations
/// </summary>
public interface IProjectRepository
{
    Task<Project?> GetByIdAsync(int id);
    Task<IEnumerable<Project>> GetByUserIdAsync(int userId);
    Task<(IEnumerable<Project> items, int total)> GetPagedAsync(int userId, PaginationRequest request);
    Task<(IEnumerable<Project> items, int total)> GetInfiniteScrollAsync(int userId, int skip, int take);
    Task<int> CreateAsync(Project project);
    Task<bool> UpdateAsync(Project project);
    Task<bool> DeleteAsync(int id);
    Task<IEnumerable<Project>> SearchAsync(int userId, string searchTerm);
}
```

Create file: `backend/ProjectTracker.API/Data/Repositories/ProjectRepository.cs`

```csharp
using Dapper;
using ProjectTracker.API.Models.Common;
using ProjectTracker.API.Models.Entities;
using System.Data;
using System.Text;

namespace ProjectTracker.API.Data.Repositories;

/// <summary>
/// Dapper-based implementation of IProjectRepository
/// </summary>
public class ProjectRepository : IProjectRepository
{
    private readonly DbConnection _dbConnection;
    private readonly ILogger<ProjectRepository> _logger;

    public ProjectRepository(DbConnection dbConnection, ILogger<ProjectRepository> logger)
    {
        _dbConnection = dbConnection;
        _logger = logger;
    }

    public async Task<Project?> GetByIdAsync(int id)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                SELECT [Id], [UserId], [Title], [Description], [Status], [Priority],
                       [StartDate], [DueDate], [CreatedAt], [UpdatedAt]
                FROM [Projects]
                WHERE [Id] = @Id";

            var project = await connection.QueryFirstOrDefaultAsync<Project>(
                sql,
                new { Id = id });

            return project;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving project {ProjectId}", id);
            throw;
        }
    }

    public async Task<IEnumerable<Project>> GetByUserIdAsync(int userId)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                SELECT [Id], [UserId], [Title], [Description], [Status], [Priority],
                       [StartDate], [DueDate], [CreatedAt], [UpdatedAt]
                FROM [Projects]
                WHERE [UserId] = @UserId
                ORDER BY [CreatedAt] DESC";

            var projects = await connection.QueryAsync<Project>(
                sql,
                new { UserId = userId });

            return projects;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving projects for user {UserId}", userId);
            throw;
        }
    }

    public async Task<(IEnumerable<Project> items, int total)> GetPagedAsync(
        int userId,
        PaginationRequest request)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            // Build WHERE clause
            var whereClause = new StringBuilder("WHERE [UserId] = @UserId");
            var parameters = new DynamicParameters();
            parameters.Add("@UserId", userId);

            if (!string.IsNullOrWhiteSpace(request.SearchTerm))
            {
                whereClause.Append(" AND ([Title] LIKE @SearchTerm OR [Description] LIKE @SearchTerm)");
                parameters.Add("@SearchTerm", $"%{request.SearchTerm}%");
            }

            // Get total count
            var countSql = $"SELECT COUNT(*) FROM [Projects] {whereClause}";
            var total = await connection.QuerySingleAsync<int>(countSql, parameters);

            // Get paged data
            var offset = (request.PageNumber - 1) * request.PageSize;
            var sortColumn = GetSafeSortColumn(request.SortBy);
            var sortDirection = request.SortDirection.ToLower() == "desc" ? "DESC" : "ASC";

            var sql = $@"
                SELECT [Id], [UserId], [Title], [Description], [Status], [Priority],
                       [StartDate], [DueDate], [CreatedAt], [UpdatedAt]
                FROM [Projects]
                {whereClause}
                ORDER BY [{sortColumn}] {sortDirection}
                OFFSET @Offset ROWS
                FETCH NEXT @PageSize ROWS ONLY";

            parameters.Add("@Offset", offset);
            parameters.Add("@PageSize", request.PageSize);

            var projects = await connection.QueryAsync<Project>(sql, parameters);

            return (projects, total);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving paged projects for user {UserId}", userId);
            throw;
        }
    }

    public async Task<(IEnumerable<Project> items, int total)> GetInfiniteScrollAsync(
        int userId,
        int skip,
        int take)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            // Get total count
            var countSql = "SELECT COUNT(*) FROM [Projects] WHERE [UserId] = @UserId";
            var total = await connection.QuerySingleAsync<int>(
                countSql,
                new { UserId = userId });

            // Get projects (take one extra to determine if there are more)
            var sql = @"
                SELECT [Id], [UserId], [Title], [Description], [Status], [Priority],
                       [StartDate], [DueDate], [CreatedAt], [UpdatedAt]
                FROM [Projects]
                WHERE [UserId] = @UserId
                ORDER BY [CreatedAt] DESC
                OFFSET @Skip ROWS
                FETCH NEXT @Take ROWS ONLY";

            var projects = await connection.QueryAsync<Project>(
                sql,
                new { UserId = userId, Skip = skip, Take = take });

            return (projects, total);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving infinite scroll projects for user {UserId}", userId);
            throw;
        }
    }

    public async Task<int> CreateAsync(Project project)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                INSERT INTO [Projects] ([UserId], [Title], [Description], [Status], [Priority], [StartDate], [DueDate])
                VALUES (@UserId, @Title, @Description, @Status, @Priority, @StartDate, @DueDate);
                SELECT CAST(SCOPE_IDENTITY() as int)";

            var id = await connection.QuerySingleAsync<int>(
                sql,
                new
                {
                    project.UserId,
                    project.Title,
                    project.Description,
                    project.Status,
                    project.Priority,
                    project.StartDate,
                    project.DueDate
                });

            _logger.LogInformation("Project created with id {ProjectId}", id);
            return id;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating project");
            throw;
        }
    }

    public async Task<bool> UpdateAsync(Project project)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                UPDATE [Projects]
                SET [Title] = @Title,
                    [Description] = @Description,
                    [Status] = @Status,
                    [Priority] = @Priority,
                    [StartDate] = @StartDate,
                    [DueDate] = @DueDate,
                    [UpdatedAt] = GETUTCDATE()
                WHERE [Id] = @Id AND [UserId] = @UserId";

            var rowsAffected = await connection.ExecuteAsync(
                sql,
                new
                {
                    project.Id,
                    project.UserId,
                    project.Title,
                    project.Description,
                    project.Status,
                    project.Priority,
                    project.StartDate,
                    project.DueDate
                });

            _logger.LogInformation("Project {ProjectId} updated", project.Id);
            return rowsAffected > 0;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating project {ProjectId}", project.Id);
            throw;
        }
    }

    public async Task<bool> DeleteAsync(int id)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = "DELETE FROM [Projects] WHERE [Id] = @Id";

            var rowsAffected = await connection.ExecuteAsync(sql, new { Id = id });

            _logger.LogInformation("Project {ProjectId} deleted", id);
            return rowsAffected > 0;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting project {ProjectId}", id);
            throw;
        }
    }

    public async Task<IEnumerable<Project>> SearchAsync(int userId, string searchTerm)
    {
        try
        {
            using var connection = await _dbConnection.CreateConnectionAsync();

            var sql = @"
                SELECT [Id], [UserId], [Title], [Description], [Status], [Priority],
                       [StartDate], [DueDate], [CreatedAt], [UpdatedAt]
                FROM [Projects]
                WHERE [UserId] = @UserId
                  AND ([Title] LIKE @SearchTerm OR [Description] LIKE @SearchTerm)
                ORDER BY [CreatedAt] DESC";

            var projects = await connection.QueryAsync<Project>(
                sql,
                new { UserId = userId, SearchTerm = $"%{searchTerm}%" });

            return projects;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error searching projects for user {UserId}", userId);
            throw;
        }
    }

    /// <summary>
    /// Prevent SQL injection by validating sort column names
    /// </summary>
    private static string GetSafeSortColumn(string? sortBy)
    {
        return sortBy?.ToLower() switch
        {
            "title" => "Title",
            "status" => "Status",
            "priority" => "Priority",
            "duedate" => "DueDate",
            "createdat" => "CreatedAt",
            _ => "CreatedAt" // Default
        };
    }
}
```

## üìã Register Repositories in DI

Update `Program.cs` to register the repositories:

```csharp
// In the SERVICES CONFIGURATION section, add:

// Database
builder.Services.AddSingleton<DbConnection>();
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<IProjectRepository, ProjectRepository>();
```

## üöÄ Initialize Database on Startup

Update `Program.cs` to run migrations:

```csharp
// After services are built, before app.Run():

// Run database migrations
using (var scope = app.Services.CreateScope())
{
    var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();
    var config = scope.ServiceProvider.GetRequiredService<IConfiguration>();
    var connectionString = config.GetConnectionString("DefaultConnection");

    try
    {
        logger.LogInformation("Starting database migrations...");
        var migrationRunner = new MigrationRunner(connectionString!, logger);
        await migrationRunner.RunMigrationsAsync();
        logger.LogInformation("Database migrations completed successfully");
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "Database migration failed: {Message}", ex.Message);
        throw;
    }
}
```

## üß™ Test the Repository

### Step 1: Create a Test Endpoint

Add to `Program.cs`:

```csharp
// Add a test endpoint to verify database connection
app.MapGet("/api/test/db", async (IUserRepository userRepo) =>
{
    var users = await userRepo.GetAllAsync();
    return Results.Ok(new { success = true, userCount = users.Count() });
})
.WithName("TestDatabase")
.WithOpenApi();
```

### Step 2: Run and Test

```powershell
cd d:\Formazione\tutorial-angular-dotnet\backend\ProjectTracker.API

# Run the API
dotnet run

# Test in browser:
# GET http://localhost:5000/api/test/db

# Should return:
# {
#   "success": true,
#   "userCount": 1
# }
```

## ‚úÖ Checkpoint

You should now have:
- ‚úÖ SQL Server running in Docker
- ‚úÖ Database schema created
- ‚úÖ Migration system implemented
- ‚úÖ Entity models defined
- ‚úÖ Repository pattern implemented with Dapper
- ‚úÖ Async database operations
- ‚úÖ Connection pooling ready
- ‚úÖ Database tested and working

## üéØ Key Takeaways: Dapper vs. EF Core

### Why Dapper for this project?

| Aspect | Dapper | Entity Framework Core |
|--------|--------|----------------------|
| **Performance** | Faster (direct SQL) | Slightly overhead (LINQ translation) |
| **Learning Curve** | Easier for .NET developers | Steeper but more powerful |
| **Control** | Full SQL control | Less control |
| **Flexibility** | Very flexible | Good for standard CRUD |
| **Migrations** | Manual SQL scripts | Auto-generated |

Dapper is perfect for learning because:
1. You write actual SQL (learning SQL deeply)
2. You understand the data access layer completely
3. You can optimize queries manually
4. It's lightweight and performant

## üöÄ Next Steps

With the database layer complete, we'll now implement authentication:

1. **Module 5**: Authentication & JWT Tokens
   - User registration
   - Password hashing with bcrypt
   - JWT token generation
   - Auth endpoints

Ready to build secure authentication?

---

**Next: [Module 5: Authentication & Authorization - JWT Tokens](./05_authentication_jwt.md)**
